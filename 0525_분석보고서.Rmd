---
title: <center> <strong> ğŸ¥ì˜í™” ì¶”ì²œì‹œìŠ¤í…œ ëª¨ë¸ êµ¬ì¶• ë° êµ¬í˜„ </strong> </center>
subtitle: <p align="right"> [Analysis Report] </p>
author: <p align="right"> 2ì¡° (ê¹€ì†Œí¬,ê¹€ì˜ì£¼,ìœ ìˆ˜ì§„,ìœ ìš©ë¹ˆ) </p>
date: <p align="right"> `r format(Sys.Date())` </p>
output:
  html_document:
    theme: cosmo
    highlight: textmate
    toc: yes
    toc_depth: 4
    toc_float: yes
    number_sections: true
    #code_folding: hide
    df_print: paged
    mainfont: NanumMyeongjo
  html_notebook: default
editor_options: 
  chunk_output_type: console
---

<style type="text/css">

h1.title {
  font-size: 36px;
  color: DarkRed;
}

</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=T, fig.align = "center", message=F, warning=F, fig.height = 6, fig.width = 5,cache=T, dpi = 300, dev = "png")
```

**ğŸ“ƒDescription**

**ğŸ“ƒmemo** 

- Code File êµ¬ì¡°
  (1) movies_í™•ì¸_0525.R
  (2) movies_íƒìƒ‰_0525.R
  (3) ratings_íƒìƒ‰_0525.R
  (4) tags_íƒìƒ‰_0525.R
  (5) movies_ìµœì¢…ë°ì´í„°êµ¬ì¶•_0525.R
  (6) movies_ëª¨ë¸ë§_0525.R - í‰ì ê¸°ë°˜
  (7) movies_ëª¨ë¸ë§2_0525.R - ì¥ë¥´ê¸°ë°˜
</br>
- Code2 File êµ¬ì¡°
  (1) ì „ì²˜ë¦¬ë³´ê³ ì„œ.Rmd
  (2) ë¶„ì„ë³´ê³ ì„œ.Rmd
  
---

# ì¶”ì²œì‹œìŠ¤í…œ ëª¨ë¸ë§: mr dataset

## ë¶„ì„í™˜ê²½ì„¤ì •
```{r}
library(data.table)
library(tidyverse)
library(dplyr)
library(ggplot2)
library(caret)
library(recommenderlab)
#help(package="recommenderlab")

m <- read.csv("./data/movies.csv", header=T)
r <- read.csv("./data/ratings.csv", header=T)
t <- read.csv("./data/tags.csv", header=T)
g <- read.csv("./data/genres.csv", header=T)

mr <- read.csv("./data/mr.csv", header=T)
final_mr <- spread(mr, key = "title", value = "rating", fill = NA)
final_mr <- final_mr[,-1]

knitr::kable(head(mr))
#knitr::kable(head(mr[order(mr$userId),]))
#knitr::kable(head(mr[order(mr$rating),]))
knitr::kable(table(r$rating))

df <- as(final_mr, 'matrix') 
df <- as(df, 'realRatingMatrix')
```
ì²« ë²ˆì§¸ í…Œì´ë¸”ì€ ë³¸ ëª¨ë¸ë§ ì‘ì—…ì— ì‚¬ìš©í•  ë°ì´í„° ë‚´ìš©ë¬¼

ë‘ ë²ˆì§¸ í…Œì´ë¸”ì€ í‰ì ë¶„í¬ë¥¼ ëŒ€ëµì ìœ¼ë¡œ ì•Œ ìˆ˜ ìˆë‹¤.

recommenderlab ë¼ì´ë¸ŒëŸ¬ë¦¬ëŠ” realRatingMatrix í˜•ì‹ì„ ì‚¬ìš©í•˜ê¸° ë•Œë¬¸ì— ë°ì´í„° í˜•ì‹ì„ ë³€í™˜í•´ì¤€ë‹¤.



## movie - rating
  - ë¶„ì„ ë°ì´í„° : 'mr' dataset
  - ë¶„ì„ ê¸°ë²• : ì‚¬ìš©ì í‰ì ì„ ì´ìš©í•œ ì‚¬ìš©ì ê¸°ë°˜ í˜‘ì—… í•„í„°ë§ ì•Œê³ ë¦¬ì¦˜(UBCF)ì„ ìƒê°í•˜ì˜€ê³ , ë” ë‚˜ì€ ì„±ëŠ¥ì„ ë³´ì´ëŠ” ì•Œê³ ë¦¬ì¦˜ë„ í•¨ê»˜ í‰ê°€í•˜ì—¬ ìµœì¢… ëª¨ë¸(ì•Œê³ ë¦¬ì¦˜)ì„ ê²°ì •í•˜ê³ ì í•¨.

### ì–´ë–»ê²Œ ë‚˜ì˜¤ëŠ”ì§€ í™•ì¸1
```{r}
set.seed(2021)
index <- sample(1:nrow(df), size = nrow(df)*0.7)

train <- df[index, ]
test  <- df[-index,]

model1 <- Recommender(train, method = "UBCF")
model1

pre <- predict(model1, newdata=test[1], n=10) #test 1 ~ 183
# as(pre, "list")

# just check
pre_list <- sapply(pre@items, function(x) {colnames(train)[x]})
table(unlist(lapply(pre_list, length)))
knitr::kable(pre_list[])
```
ë°ì´í„°ë¥¼ 7:3 ë¹„ìœ¨ë¡œ train ê³¼ test ë°ì´í„°ì…‹ìœ¼ë¡œ ë¶„í• í•œë‹¤.
ë¨¼ì € íŒŒë¼ë¯¸í„°ë¥¼ ì‹ ê²½ ì“°ì§€ ì•Šê³  ê°„ë‹¨í•œ ì‚¬ìš©ì ê¸°ë°˜ì˜ ì¶”ì²œ ì‹œìŠ¤í…œ ëª¨ë¸ë§ì„ êµ¬í˜„í•´ë´„. êµ¬í˜„ëœ ëª¨í˜• model1ì„ ê°€ì§€ê³  ì¶”ì²œ ì˜í™” 10ê°œë¥¼ ì¶œë ¥í•œë‹¤. - ë¦¬ìŠ¤íŠ¸ë¥¼ ë²¡í„°ì— ë‹´ì•„ì„œ ì›Œë“œí´ë¼ìš°ë“œë¡œ ì‹œê°í™”í•´ë³´ì.

### ì–´ë–»ê²Œ ë‚˜ì˜¤ëŠ”ì§€ í™•ì¸2 ì‹¤í–‰x

  - ì¶”ì²œì‹œìŠ¤í…œì— ì‚¬ìš©ë˜ëŠ” ëª¨ë¸ ì¦‰, ì—¬ëŸ¬ ì•Œê³ ë¦¬ì¦˜ê³¼ ê° ì•Œê³ ë¦¬ì¦˜ì— íŒŒë¼ë¯¸í„° íŠœë‹ì— ê´€í•˜ì—¬
```{r, eval=F}
## 1 (í•™ìŠµ ë‹¨ê³„)
################
model1 <- Recommender(train, method = 'POPULAR') #í‰ì ì´ ë†’ì€ ì˜í™” ìˆœ(ì¸ê¸°ìˆœ)ìœ¼ë¡œ ì¶”ì²œ
model2 <- Recommender(train, method = 'POPULAR', param=list(normalize = 'Z-score')) #í‰ì  ë°ì´í„°ë¥¼ ì‚¬ìš©ìë³„ë¡œ í‘œì¤€í™”
model3 <- Recommender(train, method='UBCF', param=list(method='pearson')) #í”¼ì–´ìŠ¨ ìƒê´€ê³„ìˆ˜ë¥¼ ì´ìš©í•˜ì—¬ ì¶”ì²œ
model4 <- Recommender(train, method='UBCF', param=list(method='cosine')) #ì½”ì‚¬ì¸ ìœ ì‚¬ë„ë¥¼ ì´ìš©í•˜ì—¬ ì¶”ì²œ
model5 <- Recommender(m, method='UBCF', param=list(method='cosine', nn=50)) #íŠ¹ì • ì‚¬ìš©ìì™€ ì¸ì ‘í•œ ì´ì›ƒì˜ ìˆ˜ë¥¼ 50ìœ¼ë¡œ ì„¤ì •

model6 <- Recommender(m, method = "IBCF", param=list(method = 'pearson'))
model7 <- Recommender(m, method = "IBCF", param=list(method = 'pearson', normalize_sim_matrix = T)) #ìœ ì‚¬ë„ë¥¼ í–‰ë³„ë¡œ normalize(í–‰ë³„ë¡œ ìœ ì‚¬ë„ í•©ì´ 1ì´ ë˜ë„ë¡ ì¬ì¡°ì •) í•œ í›„ í”¼ì–´ìŠ¨ ìƒê´€ê³„ìˆ˜ë¥¼ ì´ìš©í•˜ì—¬ ì¶”ì²œ
model8 <- Recommender(m, method = "IBCF", param=list(method = 'cosine', normalize_sim_matrix = T, k=5))

## ì°¨ì› ì¶•ì†Œë¥¼ ì´ìš©í•œ ì˜í™” ì¶”ì²œ
model9 <- Recommender(train, method = "SVD", param=list(k = 10)) #10ê°œì˜ ì°¨ì›ìœ¼ë¡œ ì¶•ì†Œ
model10 <- Recommender(train, method = "SVD", param=list(k = 20, normalize='Z-score')) #20ê°œì˜ ì°¨ì›ìœ¼ë¡œ ì¶•ì†Œ



## 2 (ì¶”ì²œ ë‹¨ê³„)
################
#1ë²ˆ(ì²«ë²ˆì§¸) ì‚¬ëŒì— ëŒ€í•´ í‰ì  ì˜ˆì¸¡
who <- 1
as(predict(model1, m[who, ], type = 'ratings'), 'list')

#1ë²ˆ(ì²«ë²ˆì§¸) ì‚¬ëŒì— ëŒ€í•´ í‰ì ì„ ì˜ˆì¸¡í›„ í‰ì ì´ ë†’ì€ ì˜í™” 5ê°œë§Œ ì¶”ì²œ
as(predict(model1, m[who, ], type = 'topNList', n=5), 'list')



#Explain
################
#Collaborative Filtering ì¡°ì •í•  ìˆ˜ ìˆëŠ” íŒŒë¼ë¯¸í„°ë³´ê¸°
#recommenderRegistry$get_entry(method = 'UBCF')
#recommenderRegistry$get_entry(method = 'IBCF')

#SVD ì—ì„œ ì¡°ì •í•  ìˆ˜ ìˆëŠ” íŒŒë¼ë¯¸í„°
#recommenderRegistry$get_entry(method = 'SVD')
```
ìœ„ ì•Œê³ ë¦¬ì¦˜ë“¤ì€ ë°˜ë³µë˜ì„œ ì‚¬ìš©ë  ê²ƒì´ê¸° ë•Œë¬¸ì— ì‚¬ìš©ìì •ì˜í•¨ìˆ˜ë¡œ ì •ì˜í•´ ë†“ëŠ”ë‹¤.

### í‰ê°€í•  ì•Œê³ ë¦¬ì¦˜ í•¨ìˆ˜ ì •ì˜
```{r}
algorithms <- list(
  
  "random"  = list(name="RANDOM"),
  "popular" = list(name="POPULAR"), 
  "popularZ" = list(name="POPULAR", param=list(normalize = "Z-score")),
  
  "userN10C" = list(name="UBCF", param=list(normalize = NULL, nn = 10, method = 'cosine')),
  "userN50C" = list(name="UBCF", param=list(normalize = NULL, nn = 50, method = 'cosine')),
  "userC50C" = list(name="UBCF", param=list(normalize = 'center', nn = 50, method = 'cosine')),
  "userZ50C" = list(name="UBCF", param=list(normalize = 'Z-score', nn = 50, method = 'cosine'))
  
  # "userN10P" = list(name="UBCF", param=list(normalize = NULL, nn = 10, method = 'pearson')), #ì˜¤ë¥˜
  # "userN50P" = list(name="UBCF", param=list(normalize = NULL, nn = 50, method = 'pearson')), #ì˜¤ë¥˜
  # "userC50P" = list(name="UBCF", param=list(normalize = 'center', nn = 50, method = 'pearson')), #ì˜¤ë¥˜
  # "userZ50P" = list(name="UBCF", param=list(normalize = 'Z-score', nn = 50, method = 'pearson')) #ì˜¤ë¥˜
)

algorithms2 <- list(
  
  'SVDZ10PT' = list(name="SVD", param=list(normalize = 'Z-score', k = 10)),
  'SVDZ50PT' = list(name="SVD", param=list(normalize = 'Z-score', k = 50)),
  'SVDZ100PT' = list(name="SVD", param=list(normalize = 'Z-score', k = 100))
)
```
random, popular, ubcf, svd, ibcfë¥¼ ì‚¬ìš©. normalize, nn, method, k ì˜µì…˜ ë“±ì´ ìˆë‹¤.

ê° ì•Œê³ ë¦¬ì¦˜ì˜ ê°œë…ì •ë„ì™€ ê°‘ ì˜µì…˜ì˜ ì˜ë¯¸ ì°¾ê¸°.

algorithms: nì„ ì–´ëŠì •ë„ ë´ì•¼í• ê¹Œ. ê·¸ë¦¬ê³  í”¼ì–´ìŠ¨ì€ ì—ëŸ¬ìˆìŒ. not-yet-implemented method for <dgCMatrix> %*% <list> í”¼ì–´ìŠ¨ì€ ê°œë³„ë¡œ ë˜ëŠ”ì§€ í™•ì¸í•„ìš”.

### ì¶”ì²œ ì‹œìŠ¤í…œì—ì„œì˜ ëª¨í˜• ì„ íƒ (í‰ì ê¸°ì¤€)
```{r}
#ëª¨í˜• í‰ê°€ë¥¼ ìœ„í•´ì„œ Traing Setê³¼ Test Set ë¶„í• 
set.seed(2021)
scheme <- evaluationScheme(df, method="split",
                           train = .8, k = 3, given = 15) 
#k: ì‹¬í”Œí•˜ê²Œ kë¥¼ ì—¬ëŸ¬ë²ˆ í• ìˆ˜ë¡ ì˜ ì„ì¸ë‹¤.
#given: íŠ¹ì • ì •ë³´ì— í¸í–¥ë˜ì§€ ì•Šê²Œ, ìµœì†Œí•œ ì˜í™”ë¥¼ 15ê°œ ë³¸ ìœ ì €ì •ë³´ë¥¼ í™œìš©í•˜ê² ë‹¤.
scheme@runsTrain

#Training Setìœ¼ë¡œ ê° ì•Œê³ ë¦¬ì¦˜ì— ëŒ€í•´ì„œ í•™ìŠµ í›„ Test Setì„ ì´ìš©í•˜ì—¬ ì •í™•ë„ í‰ê°€
results <- evaluate(scheme, algorithms, type='ratings')
results2 <- evaluate(scheme, algorithms2, type='ratings')

#ê° ëª¨í˜•ì— ëŒ€í•œ ì •í™•ë„ í™•ì¸
names(results)
names(results2)

for (i in names(results)){
  
  print(i)
  print(getConfusionMatrix(results[[i]]))
}

for (i in names(results2)){
  
  print(i)
  print(getConfusionMatrix(results2[[i]]))
}

#ê° ëª¨í˜•ì— ëŒ€í•œ ì •í™•ë„ ì‹œê°í™”
plot(results, annotate=1, legend="topleft")
plot(results2, annotate=1, legend="topleft")
```

### ì¶”ì²œ ì‹œìŠ¤í…œì—ì„œì˜ ëª¨í˜• ì„ íƒ (ì¶”ì²œëª©ë¡ê¸°ì¤€)
  - ì¶”ì²œëª©ë¡ê¸°ì¤€?? evaluateì— ë“¤ì–´ê°€ëŠ” n ì˜ë¯¸ë¬´ì—‡?
  
```{r}
#ëª¨í˜• í‰ê°€ë¥¼ ìœ„í•´ì„œ Traing Setê³¼ Test Set ë¶„í• í•˜ê¸°: 
#ë‹¨, 3ì  ì´ìƒì¼ ê²½ìš° ì¬ë¯¸ìˆê²Œ ë´¤ë‹¤ê³  ê°€ì •
set.seed(2021)
scheme <- evaluationScheme(df, method="split",
                           train = .8, k = 1, given = 15, goodRating = 3)

#Training Setìœ¼ë¡œ ê° ì•Œê³ ë¦¬ì¦˜ì— ëŒ€í•´ì„œ í•™ìŠµ í›„ Test Setì„ ì´ìš©í•˜ì—¬ ì •í™•ë„ í‰ê°€
results <- evaluate(scheme, algorithms, type='topNList', n=c(1, 3, 5, 10, 15, 20))

#ê° ëª¨í˜•ì— ëŒ€í•œ ì •í™•ë„ í™•ì¸
names(results)

for (i in names(results)){
  
  print(i)
  print(getConfusionMatrix(results[[i]]))
}

#ì •í™•ë„ ê²°ê³¼ ê·¸ë˜í”„ë¡œ ë‚˜íƒ€ë‚´ê¸°
plot(results, annotate=1, legend="topleft")
```
ì´ë¥¼ í†µí•´ ìµœì¢…ì•Œê³ ë¦¬ì¦˜ ê²°ì •


### ìœ ì‚¬ë„ëŠ” ì–´ë–»ê²Œ ê³„ì‚°ë˜ê³  ìˆì„ê¹Œ (íƒìƒ‰)
```{r}
# ìœ ì‚¬ë„
similarity_mat <- similarity(train[1:10,], method = "cosine", which = "users")
as.matrix(similarity_mat)
image(as.matrix(similarity_mat), main = "user's similiarity")

# íˆíŠ¸ë§µ
image(train[1:30,1:30], axes=FALSE, main = "10 x 10 heatmap")

# top
movie_ratings <- train[rowCounts(train) > 50, colCounts(train) > 50]
movie_ratings

minimum_movies <- quantile(rowCounts(movie_ratings), 0.98)
minimum_users <- quantile(colCounts(movie_ratings), 0.98)
image(movie_ratings[rowCounts(movie_ratings) > minimum_movies,
                    colCounts(movie_ratings) > minimum_users],
      main = "Heatmap of the top users and movies")


## ë°ì´í„°..
# qplot(table(r$rating), fill=I("steelblue"), col=I("red")) +
#   ggtitle("A distribution of the average rating per user")

# heatmap of normalized value
# image(normalized_ratings[rowCounts(normalized_ratings) > minimum_movies,
#       colCounts(normalized_ratings) > minimum_users],
#       main = "Normailized ratings of the top users")

```



### ì¶”ì²œ ì‹œìŠ¤í…œì—ì„œì˜ ëª¨í˜• ì„ íƒ (ë°ì´í„° ì¡°ì • í›„ ì¬í•™ìŠµ) ì•„ì§ ì‹¤í–‰ X
```{r, eval=F}
# ë°ì´í„° ì¡°ì • í›„ ì¬í•™ìŠµ
table(rowCounts(df))
mean(rowCounts(df))
data_modify <- df[rowCounts(df) <= 165.2918]
dim(data_modify)
boxplot(Matrix::rowMeans(data_modify), horizontal=T)



# "split", cross val.
set.seed(2021)
scheme <- evaluationScheme(data_modify, method="split",
                           train = .8, k = 3, given = 15) 

results <- evaluate(scheme, algorithms, type='ratings')
results2 <- evaluate(scheme, algorithms2, type='ratings')

plot(results, annotate=1, legend="topleft")
plot(results2, annotate=1, legend="topleft")




# ìµœì¢… ì•Œê³ ë¦¬ì¦˜ ê²°ì • ëœ ê²ƒì— ëŒ€í•˜ì—¬ 
model1 <- Recommender(train, method = 'POPULAR')
pre <- predict(model1, newdata=test[1], n=10) #test 1 ~ 183
# as(pre, "list")

# just check
pre_list <- sapply(pre@items, function(x) {colnames(train)[x]})
table(unlist(lapply(pre_list, length)))
knitr::kable(pre_list[])


# split, "cross val."
eval_sets <- evaluationScheme(data = data_modify,
                              method = "cross-validation",
                              train = 0.7,
                              k = 10,
                              goodRating = 3,
                              given = 10)

n_recommendations = c(1,5,seq(10,100,10))

# Training dataset modeling
model1 <- Recommender(data = getData(eval_sets, "train"),
                           method = "UBCF", 
                           parameter = NULL)
model1

# Prediction
pred_eval <- predict(model1, 
                     newdata = getData(eval_sets, "known"),
                     n = 10, type = "ratings")
pred_eval


# Calculate accuracy
accuracy_model1 <- calcPredictionAccuracy(x=pred_eval,
                                        data=getData(eval_sets, "unknown"),
                                        byUser=T)
head(accuracy_model1, 10)
colMeans(accuracy_model1)

# Calculate accuracy 2
# ?evaluate
algorithms <- list(
  
  RANDOM = list(name = "RANDOM", param = NULL),
  POPULAR = list(name = "POPULAR", param = NULL),
  HYBRID = list(name = "HYBRID", param =
      list(recommenders = list(
        RANDOM = list(name = "RANDOM", param = NULL),
        POPULAR = list(name = "POPULAR", param = NULL))))
)
result <- evaluate(eval_sets, algorithms, n=n_recommendations)
result
avg(result) #precision(ì •ë°€ë„), recall(ì¬í˜„ìœ¨)



plot(result, annotate=T, legend="right", main = "ROC Curve")
plot(result, "prec/rec", annotate=T,legend="right") #bad.. 
# plot(result2, annotate=T, legend="topleft")
# plot(result2, "prec/rec", annotate=T,legend="topleft")

#ë”°ë¡œ í‰ê°€í•´ì„œ resultê°’ ë„£ì€ í›„ ë¹„êµ
#ì •ë°€ë„ ì¬í˜„ìœ¨ ê³¡ì„  í•´ì„¤ find
```

> í•¨ìˆ˜ì„¤ëª…

[evaluationScheme](https://www.rdocumentation.org/packages/recommenderlab/versions/0.2-7/topics/evaluationScheme)

[HybridRecommender](https://rdrr.io/cran/recommenderlab/man/HybridRecommender.html)

![k-fold CV](./img/k-fold.png)
![ROC Curve](./img/roc.png)
[ROC EXPLAIN LINK1](https://newsight.tistory.com/53)
[ROC EXPLAIN LINK2](https://angeloyeo.github.io/2020/08/05/ROC.html)

---

# ì¶”ì²œì‹œìŠ¤í…œ ëª¨ë¸ë§: mg dataset
```{r, warning=F}
mg <- read.csv('./data/mg.csv', header=T)
final_mg <- spread(mg, key = "genres", value = "value", fill = NA)
final_mg <- final_mg[,-c(1,2)]
```

```{r}
knitr::kable(head(mg))
knitr::kable(table(mg$genres))

df2 <- as(final_mg, 'matrix') 
df2 <- as(df2, 'realRatingMatrix')
```

## ë¶„ì„í™˜ê²½ì„¤ì •
  - ë¶„ì„ ë°ì´í„° : 'mg' dataset
  - ë¶„ì„ ê¸°ë²• : ì˜í™” ìì²´ ì •ë³´ë¥¼ ì´ìš©í•œ ì•„ì´í…œ ê¸°ë°˜ í˜‘ì—… í•„í„°ë§ ì•Œê³ ë¦¬ì¦˜(IBCF)

### í‰ê°€í•  ì•Œê³ ë¦¬ì¦˜ í•¨ìˆ˜ ì •ì˜
```{r, eval=F}
algorithms <- list(
  
  "random"  = list(name="RANDOM"),
  "popular" = list(name="POPULAR"), 
  "popularZ" = list(name="POPULAR", param=list(normalize = "Z-score")),
  
  "itemZ100PF" = list(name="IBCF", param=list(normalize = 'Z-score', k = 100, method = 'pearson', normalize_sim_matrix = F)),
  "itemZ100PT" = list(name="IBCF", param=list(normalize = 'Z-score', k = 100, method = 'pearson', normalize_sim_matrix = T)),
  "itemZ100CF" = list(name="IBCF", param=list(normalize = 'Z-score', k = 100, method = 'cosine', normalize_sim_matrix = F)),
  "itemZ100CT" = list(name="IBCF", param=list(normalize = 'Z-score', k = 100, method = 'cosine', normalize_sim_matrix = T)),
  "itemZ500PT" = list(name="IBCF", param=list(normalize = 'Z-score', k = 500, method = 'pearson', normalize_sim_matrix = T)),
  "itemZ500CT" = list(name="IBCF", param=list(normalize = 'Z-score', k = 500, method = 'cosine', normalize_sim_matrix = T)),
  
  'SVDZ10PT' = list(name="SVD", param=list(normalize = 'Z-score', k = 10)),
  'SVDZ50PT' = list(name="SVD", param=list(normalize = 'Z-score', k = 50)),
  'SVDZ100PT' = list(name="SVD", param=list(normalize = 'Z-score', k = 100)),
)
```

```{r, eval=F}
set.seed(2021)
index <- sample(1:nrow(df2), size = nrow(df2)*0.7)

train <- df2[index, ]
test  <- df2[-index,]

model1 <- Recommender(train, method = "IBCF")
model1

pre <- predict(model1, newdata=test[1], n=10) #test 1 ~ 183
# as(pre, "list")

# just check
pre_list <- sapply(pre@items, function(x) {colnames(train)[x]})
table(unlist(lapply(pre_list, length)))
knitr::kable(pre_list[])
```


```{r, eval=F}
# ë°ì´í„° ì¡°ì • í›„ ì¬í•™ìŠµ
table(rowCounts(df2))
mean(rowCounts(df2))
data_modify <- df2[rowCounts(df2) <= 2.266886]
dim(data_modify)

boxplot(Matrix::rowMeans(data_modify), horizontal=T)
# ì•„IBCF ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œëŠ” ì¥ë¥´ê¸°ë°˜ ë³„ë¡œ?

eval_sets <- evaluationScheme(data = data_modify,
                              method = "cross-validation",
                              train = 0.7,
                              k = 3,
                              #goodRating = 3,
                              given = 1)

n_recommendations = c(1,5,seq(10,100,10))

# Training dataset modeling
model1 <- Recommender(data = getData(eval_sets, "train"),
                           method = "IBCF", 
                           parameter = NULL)
model1

# Prediction
pred_eval <- predict(model1, 
                     newdata = getData(eval_sets, "known"),
                     n = 10, type = "ratings")
pred_eval
```

```{r, eval=F}
# Calculate accuracy
accuracy_model1 <- calcPredictionAccuracy(x=pred_eval,
                                        data=getData(eval_sets, "unknown"),
                                        byUser=T)
head(accuracy_model1, 10)
colMeans(accuracy_model1)

# Calculate accuracy 2
# ?evaluate
algorithms <- list(
  
  RANDOM = list(name = "RANDOM", param = NULL),
  POPULAR = list(name = "POPULAR", param = NULL),
  HYBRID = list(name = "HYBRID", param =
      list(recommenders = list(
        RANDOM = list(name = "RANDOM", param = NULL),
        POPULAR = list(name = "POPULAR", param = NULL))))
)
result <- evaluate(eval_sets, algorithms, n=n_recommendations)
result
avg(result) #precision(ì •ë°€ë„), recall(ì¬í˜„ìœ¨)
```

```{r, eval=F}
plot(result, annotate=T, legend="right", main = "ROC Curve")
plot(result, "prec/rec", annotate=T,legend="right") #bad.. 
# plot(result2, annotate=T, legend="topleft")
# plot(result2, "prec/rec", annotate=T,legend="topleft")

#ë”°ë¡œ í‰ê°€í•´ì„œ resultê°’ ë„£ì€ í›„ ë¹„êµ
#ì •ë°€ë„ ì¬í˜„ìœ¨ ê³¡ì„  í•´ì„¤ find
```


---


### ì¶”ì²œì˜í™” ì‹œê°í™”
  - ì‚¬ìš©ìê¸°ë°˜(í‰ì )
  
```{r}
n=300
pre <- predict(model1, newdata=test[2], n) #test 1 ~ 183
min_rating <- min(pre@ratings[[1]])
max_rating <- max(pre@ratings[[1]])
e_value <- (max_rating-min_rating)/10

# just check
pre_list <- sapply(pre@items, function(x) {colnames(train)[x]})
pre_ratings <- pre@ratings[[1]]
for(i in 1:n){
  if(pre_ratings[i] <= max_rating && pre_ratings[i] > max_rating-e_value){
    pre_ratings[i] <- 100 #ê°€ì¤‘ì¹˜ 100
  }else if(pre_ratings[i] <= max_rating-e_value && pre_ratings[i] > max_rating-e_value*2){
    pre_ratings[i] <- 90 #ê°€ì¤‘ì¹˜ 90
  }else if(pre_ratings[i] <= max_rating-e_value*2 && pre_ratings[i] > max_rating-e_value*4){
    pre_ratings[i] <- 70 #ê°€ì¤‘ì¹˜ 70
  }else if(pre_ratings[i] <= max_rating-e_value*4 && pre_ratings[i] > max_rating-e_value*6){
    pre_ratings[i] <- 50 #ê°€ì¤‘ì¹˜ 50
  }else{
    pre_ratings[i] <- 25
  }
}

table(unlist(lapply(pre_list, length)))
knitr::kable(pre_list[])
# 
library(RColorBrewer)
library(wordcloud)
pre_vec <- c(pre_list)
pre_vec <- as.data.frame(pre_vec)
pre_vec[ , "freq" ] <- c(pre_ratings)
set.seed(1234)
par(bg="black")
pal<- brewer.pal(7,"YlOrRd")
wordcloud(words = pre_vec$pre_vec, # ë‹¨ì–´ 
                         freq = pre_vec$freq, # ë¹ˆë„
                         min.freq = 25, # ìµœì†Œ ë‹¨ì–´ ë¹ˆë„
                         max.words = 300, # í‘œí˜„ ë‹¨ì–´ ìˆ˜ 
                         random.order = F, # ê³ ë¹ˆë„ ë‹¨ì–´ ì¤‘ì•™ ë°°ì¹˜
                         rot.per = 0, # íšŒì „ ë‹¨ì–´ ë¹„ìœ¨ 
                         scale = c(1, 0.25), # ë‹¨ì–´ í¬ê¸° ë²”ìœ„
                         colors = pal) # ìƒ‰ê¹” ëª©ë¡


```





# êµ°ì§‘í™” ë¶„ì„: ì¥ë¥´

  - ë°ì´í„°ì…‹: ì˜í™” ì¥ë¥´ ì •ë³´
  - ë¶„ë¥˜ì•Œê³ ë¦¬ì¦˜: k-means, ê³„ì¸µì êµ°ì§‘ë²•, min-hash
  - ìœ ì‚¬ë„: cosine similarity, Jaccard, Euclidean

## ìœ ì €/ì¥ë¥´/í‰ì 

```{r}
head(m)
head(r)
```
ê° ìœ ì €(userId)ì— ëŒ€í•˜ì—¬ ë¬´ìŠ¨ ì¥ë¥´ë¥¼ ì„ í˜¸í•˜ëŠ”ì§€ (í‰ê· í‰ì ì„)ê³„ì‚°í•˜ê³ , ê·¸ ì •ë³´ë¡œ **ìœ ì € ê°„ ìœ ì‚¬ë„**ë¥¼ ë°”íƒ•ìœ¼ë¡œ í´ëŸ¬ìŠ¤í„°ë§ì„ ì§„í–‰

moviesë°ì´í„°ì—ëŠ” ì˜í™”id/ì œëª©/ì¥ë¥´ë¡œ êµ¬ì„±ë˜ì–´ ìˆê³  í‰ì  ì •ë³´ê°€ ìˆëŠ” ratingë°ì´í„°ëŠ” ìœ ì €id/ì˜í™”id/í‰ì /ì‹œê°„ì •ë³´ë¡œ êµ¬ì„±ë˜ì–´ ìˆë‹¤. 

```{r, eval=FALSE}
user_genres <- merge(m, r, key='movieId', all.y=T)
user_genres2 <- data.table()
n <- nrow(user_genres)
for (i in 1:n){
  
  #print(i)
  
  name_index <- as.character(user_genres[i, 1])
  item_index <- as.character(user_genres[i, 3])
  userId <- as.character(user_genres[i, 4])
  rating <- as.character(user_genres[i, 5])
  
  item_index_split_temp <- data.frame(strsplit(item_index, split = '\\|'))
  m_temp <- data.frame(cbind(name_index, item_index_split_temp, userId, rating))
  
  names(m_temp) <- c("movieId", "genres", "userId", "rating")
  
  user_genres2 <- rbind(user_genres2, m_temp)
}
rm(name_index, item_index, item_index_split_temp, m_temp)
user_genres2$rating <- as.numeric(user_genres2$rating)
user_genres2$genres <- gsub("\\(no genres listed\\)", "Unknown", user_genres2$genres)
user_genres2 <- as.data.frame(user_genres2)
glimpse(user_genres2)
#write.csv(user_genres2, "./data/user_genres.csv",row.names = F)
```
í´ëŸ¬ìŠ¤í„°ë§ì„ ìœ„í•´ ê° ìœ ì €ì— ëŒ€í•˜ì—¬ ì¥ë¥´ë³„ í‰ê· í‰ì ì„ ê³„ì‚°í•˜ì—¬ ë°ì´í„°ì…‹ì„ êµ¬ì¶•í•œë‹¤.
  - ì¥ë¥´ ë¶„ë¦¬
  - ìœ ì €ë³„ ì¥ë¥´ í‰ê· í‰ì  ê³„ì‚°

### ìœ ì €ë³„ ì¥ë¥´ í‰ê· í‰ì  ê³„ì‚°
```{r}
user_genres2 <- read.csv("./data/user_genres.csv", header=T)
glimpse(user_genres2)

ug <- user_genres2 %>% group_by(userId, genres) %>% mutate(mean_rating=mean(rating))
ug <- spread(ug, key = "genres", value = "mean_rating", fill = 0)
ug <- ug[,-c(1,3)]
knitr::kable(head(ug))
```
í´ëŸ¬ìŠ¤í„°ë§ ìœ ì‚¬ë„
  - ìœ í´ë¦¬ë””ì•ˆ: ê° ìœ ì €IDì˜ ì¥ë¥´ë³„ í‰ì ì„ Featureë¡œ ê°„ì£¼í•˜ì—¬, ë§ê·¸ëŒ€ë¡œ ìœ í´ë¦¬ë“œ ê±°ë¦¬ë¥¼ ê³„ì‚°í•˜ì—¬ ë¹„ìŠ·í•œ ìœ ì €ë¼ë¦¬ ë¬¶ëŠ” ë°©ë²•
  - ì½”ì‚¬ì¸: ê° ìœ ì €IDì˜ ì¥ë¥´ë³„ í‰ì ì„ Featureë¡œ ê°„ì£¼í•˜ì—¬, ê° ìœ ì €IDê°„ ë²¡í„°ì˜ ê°ë„ê°€ ë¹„ìŠ·í•œ ìœ ì €ë¥¼ ë¬¶ëŠ” ë°©ë²•

ê²°ê³¼:
ìœ í´ë¦¬ë“œ ê¸°ë°˜ì˜ ward ê³„ì‚°ì„ í†µí•´ 3ê°œì˜ ê·¸ë£¹ìœ¼ë¡œ ë¶„ë¥˜

---

hclust()

method : í´ëŸ¬ìŠ¤í„°ì™€ ê´€ì¸¡ì¹˜ì™€ì˜ ê±°ë¦¬ ê³„ì‚° ê¸°ì¤€ 
  - single : ìµœë‹¨ê±°ë¦¬ë²•
  - complete : ìµœì¥ê±°ë¦¬ë²•, ì™„ì „ê¸°ì¤€ë²• 
  - average : í‰ê· ê¸°ì¤€ë²• 
  - median : ì¤‘ì•™ì¤‘ì‹¬ë²• 

```{r}
### numeric data - default ìœ í´ë¦¬ë“œ(euclidean)ê±°ë¦¬
# d1 <- dist(ug)
# m1 <- hclust(d1, method = 'average')
# m2 <- hclust(d1, method = 'complete')
# m3 <- hclust(d1, method = 'single')
# m4 <- hclust(d1, method = 'median')
# m5 <- hclust(d1, method = 'ward.D')

#plot(m1, hang = -10) # hang : ê´€ì¸¡ì¹˜ë¥¼ ë§ì¶°ì£¼ê¸° ìœ„í•œ ì˜µì…˜
#rect.hclust(m1, k = 19) # í´ëŸ¬ìŠ¤í„°ë¥¼ k ê¸°ì¤€ìœ¼ë¡œ êµ°ì§‘
```

```{r}
# 1. ê±°ë¦¬í–‰ë ¬ êµ¬í•˜ê¸°
ug_scaled <- scale(ug[-1]) # ê±°ë¦¬ ê¸°ë°˜ì´ë¯€ë¡œ í‘œì¤€í™” í•„ìš” 
d1 <- dist(ug_scaled[1:10,])
as.matrix(d1)[1:4,]

# 2. ê±°ë¦¬í–‰ë ¬ ëª¨ë¸ ì ìš©(ê³„ì¸µì  êµ°ì§‘í™”)
fit <- hclust(d1, method="average")  # methodì˜ ì¢…ë¥˜ë³´ë‹¤ëŠ” ì–´ë–¤ ì˜ë„ í•˜ì— ë¶„ë¥˜í•  ê²ƒì¸ì§€ì— ë”°ë¼ ì„¤ëª…ë³€ìˆ˜ë¥¼ ì„ íƒí•˜ëŠ” ê²ƒì´ ì¤‘ìš”
plot(fit, hang=-1 , cex=0.8)

# êµ°ì§‘ ìˆ˜ ì„¤ì •
# library(NbClust)
# nc <- NbClust(ug[1:10,], distance="euclidean", method="average")

clusters <- cutree(fit, k=5)
table(clusters)     # êµ°ì§‘ë³„ ë°ì´í„° ê°œìˆ˜ í™•ì¸
rect.hclust(fit, k=5) 
```



## ì˜í™”/ì¥ë¥´ ë²¡í„°í™”
  - ëª©ì : ì˜í™” ë¶„ë¥˜?
  - ë¶„ë¥˜ì•Œê³ ë¦¬ì¦˜: k-means, knn?
  - ìœ ì‚¬ë„: cosine
  
```{r}
mg <- read.csv("./data/mg.csv", header = T)
final_mg <- spread(mg, key = "genres", value = "value", fill = 0)
final_mg <- final_mg[,-1]
```

```{r}
### binary data
# dist(final_mg[,-1], method="binary")
# dist(final_mg[,-1], method = "Jaccard")

kmeans.mg <- kmeans(final_mg[,-1],3,nstart=5)
round(sum(kmeans.mg$withinss),2) 
#kmeans.mg$cluster <- as.factor(kmeans.mg$cluster)
a=kmeans.mg$cluster
b=kmeans.mg$center

library(fpc)
plotcluster(final_mg[-1], a, main = 'k - í‰ê·  êµ°ì§‘')

```

[ì°¸ê³ ](https://velog.io/@yuhayung7296/%EB%B9%84%EC%A7%80%EB%8F%84%ED%95%99%EC%8A%B5-%EA%B8%B0%EB%B2%95%EC%9D%B8-%EA%B5%B0%EC%A7%91%EB%B6%84%EC%84%9Dclustering-%EA%B8%B0%EB%B2%95-in-R)


# ì—°ê´€ì„± ë¶„ì„: ì¥ë¥´, íƒœê·¸

  - EDA: í‰ì  ë¶„í¬, í’ˆì‚¬ ë³„ ê¸ë¶€ì • ë¶„í¬
  - word2vecì„ í™œìš©í•œ ì›Œë“œì„ë² ë”©
  - K-meansë¥¼ í™œìš©í•œ êµ°ì§‘í™”
  - ì´ì™¸ì— ì „ì²˜ë¦¬ë‚˜ WordCloud

---

# ê³ ë ¤ì‚¬í•­

  - íŒ¨í‚¤ì§€ ë‚´ ë‹¤ì–‘í•œ í•¨ìˆ˜ë“¤ì„ ë³´ë‹¤ ì ì ˆí•˜ê²Œ ì‚¬ìš©í•˜ê¸° ìœ„í•´ ì´ë¡  í•™ìŠµì€ í•„ìš”í•˜ë‹¤.

  - ìœ„ íŒ¨í‚¤ì§€ëŠ” ì§€ì†ì ìœ¼ë¡œ ì—…ê·¸ë ˆì´ë“œê°€ ë˜ê³  ìˆê¸° ë•Œë¬¸ì— [Reference Manual](https://cran.r-project.org/web/packages/recommenderlab/recommenderlab.pdf)ì„ í™œìš©í•œë‹¤.

---

# ë¬¸ì œì 

---

# í¬ë§ì‚¬í•­

  - Rê³¼ R shinyë¥¼ í™œìš©í•œ ì¶”ì²œì‹œìŠ¤í…œ êµ¬í˜„
  - sample: https://andreasvoglstatworx.shinyapps.io/apptest/

---

**ğŸ“ƒì°¸ê³ **

  - http://statkclee.github.io/parallel-r/recommendation-sparklyr.html
  - https://rstatistics.tistory.com/31#- 
  - [R ìƒ‰ìƒí‘œ](https://rfriend.tistory.com/150)
  - [ì¥ë¥´ ìƒê´€ê´€ê³„ë¥¼ ì‚¬ìš©í•œ ì˜í™”ì¶”ì²œ ì•Œê³ ë¦¬ì¦˜](https://www.kci.go.kr/kciportal/ci/sereArticleSearch/ciSereArtiView.kci?sereArticleSearchBean.artiId=ART002625066)




